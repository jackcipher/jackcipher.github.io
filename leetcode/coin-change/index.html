<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Coin Change | Jack</title>
<meta name=keywords content><meta name=description content="Coin Change II In the &ldquo;Coin Change II&rdquo; problem, we are given coins of various denominations and a specific amount. Our task is to determine the number of different ways we can make up that amount using the coins. Unlike other coin change problems where we need to minimize or maximize the number of coins, here we need to find the total number of possible combinations.
For instance, with coins [1,2,5] and amount 5, we have the following combinations:"><meta name=author content><link rel=canonical href=https://jackcipher.github.io/leetcode/coin-change/><link crossorigin=anonymous href=/assets/css/stylesheet.92e49ebef1349125dd8bc0d8e4add7665a310345a18a86237b714e7c41ffca40.css integrity="sha256-kuSevvE0kSXdi8DY5K3XZloxA0WhioYje3FOfEH/ykA=" rel="preload stylesheet" as=style><link rel=icon href=https://jackcipher.github.io/static/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jackcipher.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jackcipher.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jackcipher.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jackcipher.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Coin Change"><meta property="og:description" content="Coin Change II In the &ldquo;Coin Change II&rdquo; problem, we are given coins of various denominations and a specific amount. Our task is to determine the number of different ways we can make up that amount using the coins. Unlike other coin change problems where we need to minimize or maximize the number of coins, here we need to find the total number of possible combinations.
For instance, with coins [1,2,5] and amount 5, we have the following combinations:"><meta property="og:type" content="article"><meta property="og:url" content="https://jackcipher.github.io/leetcode/coin-change/"><meta property="article:section" content="leetcode"><meta property="article:published_time" content="2024-01-14T00:15:50+08:00"><meta property="article:modified_time" content="2024-01-14T00:15:50+08:00"><meta property="og:site_name" content="Jack"><meta name=twitter:card content="summary"><meta name=twitter:title content="Coin Change"><meta name=twitter:description content="Coin Change II In the &ldquo;Coin Change II&rdquo; problem, we are given coins of various denominations and a specific amount. Our task is to determine the number of different ways we can make up that amount using the coins. Unlike other coin change problems where we need to minimize or maximize the number of coins, here we need to find the total number of possible combinations.
For instance, with coins [1,2,5] and amount 5, we have the following combinations:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Leetcodes","item":"https://jackcipher.github.io/leetcode/"},{"@type":"ListItem","position":3,"name":"Coin Change","item":"https://jackcipher.github.io/leetcode/coin-change/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Coin Change","name":"Coin Change","description":"Coin Change II In the \u0026ldquo;Coin Change II\u0026rdquo; problem, we are given coins of various denominations and a specific amount. Our task is to determine the number of different ways we can make up that amount using the coins. Unlike other coin change problems where we need to minimize or maximize the number of coins, here we need to find the total number of possible combinations.\nFor instance, with coins [1,2,5] and amount 5, we have the following combinations:","keywords":[],"articleBody":"Coin Change II In the “Coin Change II” problem, we are given coins of various denominations and a specific amount. Our task is to determine the number of different ways we can make up that amount using the coins. Unlike other coin change problems where we need to minimize or maximize the number of coins, here we need to find the total number of possible combinations.\nFor instance, with coins [1,2,5] and amount 5, we have the following combinations:\n5 = 5 5 = 2 + 2 + 1 5 = 2 + 1 + 1 + 1 5 = 1 + 1 + 1 + 1 + 1 Hence, there are 4 ways to make up the amount 5 using the coins [1,2,5].\nApproach The intuitive way to approach this problem is by leveraging dynamic programming. We can envision a solution where, for each coin, we update the number of ways to create every amount from 0 to the given amount.\nUsing a 1D Dynamic Programming Array To find the solution in an optimized manner, we use a one-dimensional array, dp, of size amount + 1, where dp[i] represents the number of ways to make up the amount i using the coins considered so far.\nInitialize dp with all zeros and set dp[0] to 1 since there’s only one way to make up amount 0, which is by not choosing any coin. For each coin in coins, update the array dp from the coin value to the total amount. For each amount i from the coin value to the total amount, increment dp[i] by dp[i - coin_value]. The final answer will be dp[amount]. Example Given the sample example with coins ([1,2,5]) and amount (5), let’s visualize how the dp array changes with each iteration:\nInitialization:\ndp = [1, 0, 0, 0, 0, 0] Processing coin (1):\nFor each (j) from (1) to (5), add dp[j - 1] to dp[j] After this step: dp = [1, 1, 1, 1, 1, 1] Processing coin (2):\nFor each (j) from (2) to (5), add dp[j - 2] to dp[j] After this step: dp = [1, 1, 2, 2, 3, 3] Processing coin (5):\nFor (j = 5), add dp[0] to dp[5] After this step: dp = [1, 1, 2, 2, 3, 4] Now, let’s visualize these iterations using a table.\nHere’s a tabular representation of the algorithm’s progression for the given example:\nIteration 0 1 2 3 4 5 Initial 1 0 0 0 0 0 Coin 1 1 1 1 1 1 1 Coin 2 1 1 2 2 3 3 Coin 5 1 1 2 2 3 4 The “Initial” row indicates the state of the dp array right after initialization. Each subsequent row represents the state of the dp array after processing the respective coin. From the table, we can trace how the algorithm calculates the number of combinations for each amount using the available coins. The final value in the dp array, dp[5], gives the total number of ways to make up the amount 5 using the coins [1,2,5], which is 4 in this case.\nRationale The solution’s efficiency comes from its bottom-up construction. By building upon previously computed solutions for smaller amounts, we avoid redundant calculations. This method ensures that by the time we want to compute the number of ways for a particular amount, we’ve already determined the number of ways for all smaller amounts using the current set of coins.\nComplexity Time Complexity: O(amount×len(coins))O(\\text{amount} \\times \\text{len(coins)})O(amount×len(coins))\nSpace Complexity: O(amount)O(\\text{amount})O(amount)\nThis optimized solution ensures that we’re using both time and space resources efficiently.\n","wordCount":"597","inLanguage":"zh","datePublished":"2024-01-14T00:15:50+08:00","dateModified":"2024-01-14T00:15:50+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://jackcipher.github.io/leetcode/coin-change/"},"publisher":{"@type":"Organization","name":"Jack","logo":{"@type":"ImageObject","url":"https://jackcipher.github.io/static/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jackcipher.github.io accesskey=h title="Jack (Alt + H)">Jack</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jackcipher.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://jackcipher.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jackcipher.github.io/leetcode/ title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Coin Change</h1><div class=post-meta><span title='2024-01-14 00:15:50 +0800 +0800'>2024-01-14</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><div class=item><div class=circle></div><a href=#coin-change-ii aria-label="Coin Change II">Coin Change II</a></div><ul><li><div class=item><div class=circle></div><a href=#approach aria-label=Approach>Approach</a></div></li><li><div class=item><div class=circle></div><a href=#using-a-1d-dynamic-programming-array aria-label="Using a 1D Dynamic Programming Array">Using a 1D Dynamic Programming Array</a></div></li><li><div class=item><div class=circle></div><a href=#example aria-label=Example>Example</a></div></li><li><div class=item><div class=circle></div><a href=#rationale aria-label=Rationale>Rationale</a></div></li><li><div class=item><div class=circle></div><a href=#complexity aria-label=Complexity>Complexity</a></div></li></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){history.scrollRestoration&&(history.scrollRestoration="manual"),checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"),document.querySelector(`.inner ul li .item:has(a[href="#${t}"])`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?(document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"),document.querySelector(`.inner ul li .item:has(a[href="#${t}"])`).classList.add("active")):(document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active"),document.querySelector(`.inner ul li .item:has(a[href="#${t}"])`).classList.remove("active"))})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=coin-change-ii>Coin Change II<a hidden class=anchor aria-hidden=true href=#coin-change-ii>#</a></h2><p>In the &ldquo;Coin Change II&rdquo; problem, we are given coins of various denominations and a specific amount. Our task is to determine the number of different ways we can make up that amount using the coins. Unlike other coin change problems where we need to minimize or maximize the number of coins, here we need to find the total number of possible combinations.</p><p>For instance, with coins [1,2,5] and amount 5, we have the following combinations:</p><ol><li>5 = 5</li><li>5 = 2 + 2 + 1</li><li>5 = 2 + 1 + 1 + 1</li><li>5 = 1 + 1 + 1 + 1 + 1</li></ol><p>Hence, there are 4 ways to make up the amount 5 using the coins [1,2,5].</p><h3 id=approach>Approach<a hidden class=anchor aria-hidden=true href=#approach>#</a></h3><p>The intuitive way to approach this problem is by leveraging dynamic programming. We can envision a solution where, for each coin, we update the number of ways to create every amount from 0 to the given amount.</p><h3 id=using-a-1d-dynamic-programming-array>Using a 1D Dynamic Programming Array<a hidden class=anchor aria-hidden=true href=#using-a-1d-dynamic-programming-array>#</a></h3><p>To find the solution in an optimized manner, we use a one-dimensional array, <code>dp</code>, of size <code>amount + 1</code>, where <code>dp[i]</code> represents the number of ways to make up the amount <code>i</code> using the coins considered so far.</p><ol><li>Initialize <code>dp</code> with all zeros and set <code>dp[0]</code> to 1 since there&rsquo;s only one way to make up amount 0, which is by not choosing any coin.</li><li>For each coin in <code>coins</code>, update the array <code>dp</code> from the coin value to the total amount.</li><li>For each amount <code>i</code> from the coin value to the total amount, increment <code>dp[i]</code> by <code>dp[i - coin_value]</code>.</li><li>The final answer will be <code>dp[amount]</code>.</li></ol><h3 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h3><p>Given the sample example with coins ([1,2,5]) and amount (5), let&rsquo;s visualize how the <code>dp</code> array changes with each iteration:</p><ol><li><p>Initialization:</p><ul><li><code>dp = [1, 0, 0, 0, 0, 0]</code></li></ul></li><li><p>Processing coin (1):</p><ul><li>For each (j) from (1) to (5), add <code>dp[j - 1]</code> to <code>dp[j]</code></li><li>After this step: <code>dp = [1, 1, 1, 1, 1, 1]</code></li></ul></li><li><p>Processing coin (2):</p><ul><li>For each (j) from (2) to (5), add <code>dp[j - 2]</code> to <code>dp[j]</code></li><li>After this step: <code>dp = [1, 1, 2, 2, 3, 3]</code></li></ul></li><li><p>Processing coin (5):</p><ul><li>For (j = 5), add <code>dp[0]</code> to <code>dp[5]</code></li><li>After this step: <code>dp = [1, 1, 2, 2, 3, 4]</code></li></ul></li></ol><p>Now, let&rsquo;s visualize these iterations using a table.</p><p>Here&rsquo;s a tabular representation of the algorithm&rsquo;s progression for the given example:</p><table><thead><tr><th>Iteration</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Initial</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>Coin 1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Coin 2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td></tr><tr><td>Coin 5</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><ul><li>The &ldquo;Initial&rdquo; row indicates the state of the <code>dp</code> array right after initialization.</li><li>Each subsequent row represents the state of the <code>dp</code> array after processing the respective coin.</li></ul><p>From the table, we can trace how the algorithm calculates the number of combinations for each amount using the available coins. The final value in the <code>dp</code> array, <code>dp[5]</code>, gives the total number of ways to make up the amount 5 using the coins [1,2,5], which is 4 in this case.</p><h3 id=rationale>Rationale<a hidden class=anchor aria-hidden=true href=#rationale>#</a></h3><p>The solution&rsquo;s efficiency comes from its bottom-up construction. By building upon previously computed solutions for smaller amounts, we avoid redundant calculations. This method ensures that by the time we want to compute the number of ways for a particular amount, we&rsquo;ve already determined the number of ways for all smaller amounts using the current set of coins.</p><h3 id=complexity>Complexity<a hidden class=anchor aria-hidden=true href=#complexity>#</a></h3><p><strong>Time Complexity:</strong> O(amount×len(coins))O(\text{amount} \times \text{len(coins)})O(amount×len(coins))</p><p><strong>Space Complexity:</strong> O(amount)O(\text{amount})O(amount)</p><p>This optimized solution ensures that we&rsquo;re using both time and space resources efficiently.</p></div><footer class=post-footer><ul class=post-tags></ul></footer><style>.utterances{border-radius:var(--radius);transition:height .3s}</style><script src=https://utteranc.es/client.js repo=jackcipher/blog-comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://jackcipher.github.io>Jack</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>