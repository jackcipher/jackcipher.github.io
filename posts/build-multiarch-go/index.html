<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>构建跨平台 Go 服务 | Jack</title>
<meta name=keywords content><meta name=description content="在过去，我的开发主机一直都是 x86_64 架构的 MacBook Pro，而我的服务器的环境也是 x86_64 架构的 CentOS.在这之前，我一直不用为支持多架构 Docker 镜像构建而烦恼。"><meta name=author content><link rel=canonical href=https://jackcipher.github.io/posts/build-multiarch-go/><link crossorigin=anonymous href=/assets/css/stylesheet.6d2a56672a184dd08474afa0ff45cc4aed56bca376a5d09295be5de53d4ed0c0.css integrity="sha256-bSpWZyoYTdCEdK+g/0XMSu1WvKN2pdCSlb5d5T1O0MA=" rel="preload stylesheet" as=style><link rel=icon href=https://jackcipher.github.io/static/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jackcipher.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jackcipher.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jackcipher.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jackcipher.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="构建跨平台 Go 服务"><meta property="og:description" content="在过去，我的开发主机一直都是 x86_64 架构的 MacBook Pro，而我的服务器的环境也是 x86_64 架构的 CentOS.在这之前，我一直不用为支持多架构 Docker 镜像构建而烦恼。"><meta property="og:type" content="article"><meta property="og:url" content="https://jackcipher.github.io/posts/build-multiarch-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-20T13:50:58+08:00"><meta property="article:modified_time" content="2022-09-20T13:50:58+08:00"><meta property="og:site_name" content="Jack"><meta name=twitter:card content="summary"><meta name=twitter:title content="构建跨平台 Go 服务"><meta name=twitter:description content="在过去，我的开发主机一直都是 x86_64 架构的 MacBook Pro，而我的服务器的环境也是 x86_64 架构的 CentOS.在这之前，我一直不用为支持多架构 Docker 镜像构建而烦恼。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jackcipher.github.io/posts/"},{"@type":"ListItem","position":3,"name":"构建跨平台 Go 服务","item":"https://jackcipher.github.io/posts/build-multiarch-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"构建跨平台 Go 服务","name":"构建跨平台 Go 服务","description":"在过去，我的开发主机一直都是 x86_64 架构的 MacBook Pro，而我的服务器的环境也是 x86_64 架构的 CentOS.在这之前，我一直不用为支持多架构 Docker 镜像构建而烦恼。","keywords":[],"articleBody":"在过去，我的开发主机一直都是 x86_64 架构的 MacBook Pro，而我的服务器的环境也是 x86_64 架构的 CentOS.在这之前，我一直不用为支持多架构 Docker 镜像构建而烦恼。直到公司，给我们更新了一批 M1 的 MacBook Pro。如果在 x86 系统上运行直接构建在 ARM/M1 打包的镜像，通常会遇到以下错误：\n1 standard_init_linux.go:211: exec user process caused \"exec format error\" 这意味着，容器中的二进制文件并不是为当前 CPU 架构而构建的。\n那么如何构建一个多 CPU 架构的镜像呢？本文会介绍两种方式，一种是通过 manifest ，另一种则是通过 buildx.\nmanifest 方式 什么是 manifest 为了解决这个问题，Docker 社区提出了当前被称作 Docker manifest 的方案，也称作多架构镜像(multi-arch image)或 fat manifest.单个 Manifest 其实是一个镜像的元数据信息文件，存储了诸如 layers，大小，digest，操作系统，构建的 CPU 架构等。而一个 manifest 列表则允许将多个镜像放到一个描述文件中。 有了 Manifest 后，当用户执行 docker pull 或者 docker run 时，Docker Engine 则会根据运行的操作系统选择要拉取的镜像。\n如何创建 manifest 上面提到，一个 manifest 列表是包含多个 image 的。在创建 manifest 之前，我们把需要打包的 image 先构建出来。为了方便演示，这里将从 Docker Hub 中拉取两个不同架构的镜像。\n以 alpine:3.19 为例，通过指定 digest 方式，拉取两组镜像，分别为 arm-v6, amd64.下表列出了拉取的两组不同架构的 Alpine 镜像的 digest 值:\nCPU 架构 digest 值 arm-v6 sha256:45eeb55d6698849eb12a02d3e9a323e3d8e656882ef4ca542d1dda0274231e84 amd64 sha256:13b7e62e8df80264dbb747995705a986aa530415763a6c58f84a3ca8af9a5bcd 同理，得到另一个镜像为 3.19-amd64。在使用 manifest 前，需要确保目标镜像在仓库中存在。只有 push 到仓库后的镜像，才能使用 manifest 命令。\n将镜像 tag 后，推送至 harbor，得到的镜像如下\n镜像名 CPU 架构 harbor.baijiayun.com/proxy/alpine3.19:arm-v6 arm-v6 harbor.baijiayun.com/proxy/alpine3.19:amd64 amd64 如上图所示，在 Harbor 中，得到了两个不同 tag 的镜像。\n创建 manifest 执行 manifest 命令如下，可以将这两个镜像组装成一个 manifest:\n1 docker manifest create harbor.baijiayun.com/proxy/alpine:3.19 harbor.baijiayun.com/proxy/alpine3.19:arm-v6 harbor.baijiayun.com/proxy/alpine3.19:amd64 给 manifest 增加注解 1 2 docker manifest annotate harbor.baijiayun.com/proxy/alpine:3.19 harbor.baijiayun.com/proxy/alpine3.19:arm-v6 --os linux --arch arm64 docker manifest annotate harbor.baijiayun.com/proxy/alpine:3.19 harbor.baijiayun.com/proxy/alpine3.19:amd64 --os linux --arch amd64 推送至远程 1 docker manifest push harbor.baijiayun.com/proxy/alpine:3.19 如上图所示，manifest 推送至 harbor 后，就好像变成了一个镜像。拉取这个 manifest 等同于拉取一个镜像。并且，因为有了注解，Docker Engine 也能根据当前的操作系统来选择拉取不同的镜像。\nmanifest 文件 inspect 执行 docker manifest inspect 命令如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ➜ ~ docker manifest inspect harbor.baijiayun.com/proxy/alpine:3.19 { \"schemaVersion\": 2, \"mediaType\": \"application/vnd.docker.distribution.manifest.list.v2+json\", \"manifests\": [ { \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\", \"size\": 528, \"digest\": \"sha256:13b7e62e8df80264dbb747995705a986aa530415763a6c58f84a3ca8af9a5bcd\", \"platform\": { \"architecture\": \"amd64\", \"os\": \"linux\" } }, { \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\", \"size\": 528, \"digest\": \"sha256:45eeb55d6698849eb12a02d3e9a323e3d8e656882ef4ca542d1dda0274231e84\", \"platform\": { \"architecture\": \"arm64\", \"os\": \"linux\", \"variant\": \"v6\" } } ] } 可以看到，manifest 实际上是一个 JSON 对象，包含了不同的镜像描述。Docker Engine 只需要 .manifests[].platform 即可决定是否拉取当前镜像。\n","wordCount":"944","inLanguage":"zh","datePublished":"2022-09-20T13:50:58+08:00","dateModified":"2022-09-20T13:50:58+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://jackcipher.github.io/posts/build-multiarch-go/"},"publisher":{"@type":"Organization","name":"Jack","logo":{"@type":"ImageObject","url":"https://jackcipher.github.io/static/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jackcipher.github.io accesskey=h title="Jack (Alt + H)">Jack</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jackcipher.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://jackcipher.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jackcipher.github.io/oral/ title=Oral><span>Oral</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">构建跨平台 Go 服务</h1></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#manifest-%e6%96%b9%e5%bc%8f aria-label="manifest 方式">manifest 方式</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af-manifest aria-label="什么是 manifest">什么是 manifest</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba-manifest aria-label="如何创建 manifest">如何创建 manifest</a><ul><li><a href=#%e5%88%9b%e5%bb%ba-manifest aria-label="创建 manifest">创建 manifest</a></li><li><a href=#%e7%bb%99-manifest-%e5%a2%9e%e5%8a%a0%e6%b3%a8%e8%a7%a3 aria-label="给 manifest 增加注解">给 manifest 增加注解</a></li><li><a href=#%e6%8e%a8%e9%80%81%e8%87%b3%e8%bf%9c%e7%a8%8b aria-label=推送至远程>推送至远程</a></li><li><a href=#manifest-%e6%96%87%e4%bb%b6-inspect aria-label="manifest 文件 inspect">manifest 文件 inspect</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>在过去，我的开发主机一直都是 x86_64 架构的 MacBook Pro，而我的服务器的环境也是 x86_64 架构的 CentOS.在这之前，我一直不用为支持多架构 Docker 镜像构建而烦恼。直到公司，给我们更新了一批 M1 的 MacBook Pro。如果在 x86 系统上运行直接构建在 ARM/M1 打包的镜像，通常会遇到以下错误：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>standard_init_linux.go:211: exec user process caused &#34;exec format error&#34;
</span></span></code></pre></td></tr></table></div></div><p>这意味着，容器中的二进制文件并不是为当前 CPU 架构而构建的。</p><p>那么如何构建一个多 CPU 架构的镜像呢？本文会介绍两种方式，一种是通过 manifest ，另一种则是通过 buildx.</p><h3 id=manifest-方式>manifest 方式<a hidden class=anchor aria-hidden=true href=#manifest-方式>#</a></h3><h4 id=什么是-manifest>什么是 manifest<a hidden class=anchor aria-hidden=true href=#什么是-manifest>#</a></h4><p>为了解决这个问题，Docker 社区提出了当前被称作 <a href=https://docs.docker.com/engine/reference/commandline/manifest/>Docker manifest</a> 的方案，也称作多架构镜像(multi-arch image)或 fat manifest.单个 Manifest 其实是一个镜像的元数据信息文件，存储了诸如 layers，大小，digest，操作系统，构建的 CPU 架构等。而一个 manifest 列表则允许将多个镜像放到一个描述文件中。
有了 Manifest 后，当用户执行 <code>docker pull</code> 或者 <code>docker run</code> 时，Docker Engine 则会根据运行的操作系统选择要拉取的镜像。</p><h4 id=如何创建-manifest>如何创建 manifest<a hidden class=anchor aria-hidden=true href=#如何创建-manifest>#</a></h4><p>上面提到，一个 manifest 列表是包含多个 image 的。在创建 manifest 之前，我们把需要打包的 image 先构建出来。为了方便演示，这里将从 Docker Hub 中拉取两个不同架构的镜像。</p><p>以 <a href="https://hub.docker.com/layers/library/alpine/3.19.0/images/sha256-13b7e62e8df80264dbb747995705a986aa530415763a6c58f84a3ca8af9a5bcd?context=explore">alpine:3.19</a> 为例，通过指定 digest 方式，拉取两组镜像，分别为 arm-v6, amd64.下表列出了拉取的两组不同架构的 Alpine 镜像的 digest 值:</p><table><thead><tr><th>CPU 架构</th><th>digest 值</th></tr></thead><tbody><tr><td>arm-v6</td><td>sha256:45eeb55d6698849eb12a02d3e9a323e3d8e656882ef4ca542d1dda0274231e84</td></tr><tr><td>amd64</td><td>sha256:13b7e62e8df80264dbb747995705a986aa530415763a6c58f84a3ca8af9a5bcd</td></tr></tbody></table><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/jackcipher/static_resource@master/imgs/obsidian20240107000418.png alt=image.png></p><p>同理，得到另一个镜像为 <code>3.19-amd64</code>。在使用 manifest 前，需要确保目标镜像在仓库中存在。只有 push 到仓库后的镜像，才能使用 manifest 命令。</p><p>将镜像 tag 后，推送至 harbor，得到的镜像如下</p><table><thead><tr><th>镜像名</th><th>CPU 架构</th></tr></thead><tbody><tr><td>harbor.baijiayun.com/proxy/alpine3.19:arm-v6</td><td>arm-v6</td></tr><tr><td>harbor.baijiayun.com/proxy/alpine3.19:amd64</td><td>amd64</td></tr></tbody></table><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/jackcipher/static_resource@master/imgs/obsidian20240107111527.png alt=image.png></p><p>如上图所示，在 Harbor 中，得到了两个不同 tag 的镜像。</p><h5 id=创建-manifest>创建 manifest<a hidden class=anchor aria-hidden=true href=#创建-manifest>#</a></h5><p>执行 manifest 命令如下，可以将这两个镜像组装成一个 manifest:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>docker manifest create harbor.baijiayun.com/proxy/alpine:3.19 harbor.baijiayun.com/proxy/alpine3.19:arm-v6 harbor.baijiayun.com/proxy/alpine3.19:amd64
</span></span></code></pre></td></tr></table></div></div><h5 id=给-manifest-增加注解>给 manifest 增加注解<a hidden class=anchor aria-hidden=true href=#给-manifest-增加注解>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>docker manifest annotate harbor.baijiayun.com/proxy/alpine:3.19 harbor.baijiayun.com/proxy/alpine3.19:arm-v6 --os linux --arch arm64
</span></span><span class=line><span class=cl>docker manifest annotate harbor.baijiayun.com/proxy/alpine:3.19 harbor.baijiayun.com/proxy/alpine3.19:amd64 --os linux --arch amd64
</span></span></code></pre></td></tr></table></div></div><h5 id=推送至远程>推送至远程<a hidden class=anchor aria-hidden=true href=#推送至远程>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>docker manifest push harbor.baijiayun.com/proxy/alpine:3.19
</span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/jackcipher/static_resource@master/imgs/obsidian20240107114724.png alt=image.png></p><p>如上图所示，manifest 推送至 harbor 后，就好像变成了一个镜像。拉取这个 manifest 等同于拉取一个镜像。并且，因为有了注解，Docker Engine 也能根据当前的操作系统来选择拉取不同的镜像。</p><h5 id=manifest-文件-inspect>manifest 文件 inspect<a hidden class=anchor aria-hidden=true href=#manifest-文件-inspect>#</a></h5><p>执行 <code>docker manifest inspect</code> 命令如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=err>➜</span>  <span class=o>~</span> <span class=n>docker</span> <span class=n>manifest</span> <span class=n>inspect</span> <span class=n>harbor</span><span class=o>.</span><span class=n>baijiayun</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>proxy</span><span class=o>/</span><span class=n>alpine</span><span class=p>:</span><span class=mf>3.19</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=s2>&#34;schemaVersion&#34;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=s2>&#34;mediaType&#34;</span><span class=p>:</span> <span class=s2>&#34;application/vnd.docker.distribution.manifest.list.v2+json&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=s2>&#34;manifests&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=s2>&#34;mediaType&#34;</span><span class=p>:</span> <span class=s2>&#34;application/vnd.docker.distribution.manifest.v2+json&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=s2>&#34;size&#34;</span><span class=p>:</span> <span class=mi>528</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=s2>&#34;digest&#34;</span><span class=p>:</span> <span class=s2>&#34;sha256:13b7e62e8df80264dbb747995705a986aa530415763a6c58f84a3ca8af9a5bcd&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=s2>&#34;platform&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;architecture&#34;</span><span class=p>:</span> <span class=s2>&#34;amd64&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;os&#34;</span><span class=p>:</span> <span class=s2>&#34;linux&#34;</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=s2>&#34;mediaType&#34;</span><span class=p>:</span> <span class=s2>&#34;application/vnd.docker.distribution.manifest.v2+json&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=s2>&#34;size&#34;</span><span class=p>:</span> <span class=mi>528</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=s2>&#34;digest&#34;</span><span class=p>:</span> <span class=s2>&#34;sha256:45eeb55d6698849eb12a02d3e9a323e3d8e656882ef4ca542d1dda0274231e84&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=s2>&#34;platform&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;architecture&#34;</span><span class=p>:</span> <span class=s2>&#34;arm64&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;os&#34;</span><span class=p>:</span> <span class=s2>&#34;linux&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;variant&#34;</span><span class=p>:</span> <span class=s2>&#34;v6&#34;</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到，manifest 实际上是一个 JSON 对象，包含了不同的镜像描述。Docker Engine 只需要 <code>.manifests[].platform</code> 即可决定是否拉取当前镜像。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://jackcipher.github.io/posts/logstash-in-kuberentes/><span class=title>« 上一页</span><br><span>Logstash in Kuberentes</span>
</a><a class=next href=https://jackcipher.github.io/posts/prom_relabel/><span class=title>下一页 »</span><br><span>Prometheus Relabel 总结</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://jackcipher.github.io>Jack</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css/+esm><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>