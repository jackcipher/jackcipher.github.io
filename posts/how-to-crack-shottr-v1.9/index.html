<!doctype html><html lang=zh dir=auto data-theme=light><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法 | Jack</title><meta name=keywords content="逆向工程,效率工具,macOS"><meta name=description content="
        一场有趣的猫鼠游戏：当开发者针对旧版破解方案引入了硬编码的校验逻辑，我们该如何层层剥茧，还原其背后的算法真相？
    0x01 前言在 8 月份的文章中，我分享了如何通过 mitmproxy 激活 Shottr。原本以为这只是一个简单的 HTTP 数据包篡改游戏，但作者在 v1.9.1 版本中打了一个「反击战」。"><meta name=author content><link rel=canonical href=https://jackcipher.github.io/posts/how-to-crack-shottr-v1.9/><link crossorigin=anonymous href=/assets/css/stylesheet.12ab6ce96a810d605492269171847ea9697dda34c4f86dc1ff78b94cedca437a.css integrity="sha256-Eqts6WqBDWBUkiaRcYR+qWl92jTE+G3B/3i5TO3KQ3o=" rel="preload stylesheet" as=style><link rel=icon href=https://jackcipher.github.io/static/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jackcipher.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jackcipher.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jackcipher.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jackcipher.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://jackcipher.github.io/posts/how-to-crack-shottr-v1.9/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"&&(document.querySelector("html").dataset.theme="dark")</script><div id=reading-progress aria-hidden=true></div><meta property="og:url" content="https://jackcipher.github.io/posts/how-to-crack-shottr-v1.9/"><meta property="og:site_name" content="Jack"><meta property="og:title" content="逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法"><meta property="og:description" content=" 一场有趣的猫鼠游戏：当开发者针对旧版破解方案引入了硬编码的校验逻辑，我们该如何层层剥茧，还原其背后的算法真相？
0x01 前言在 8 月份的文章中，我分享了如何通过 mitmproxy 激活 Shottr。原本以为这只是一个简单的 HTTP 数据包篡改游戏，但作者在 v1.9.1 版本中打了一个「反击战」。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-29T21:50:58+00:00"><meta property="article:modified_time" content="2025-12-29T21:50:58+00:00"><meta property="article:tag" content="逆向工程"><meta property="article:tag" content="效率工具"><meta property="article:tag" content="MacOS"><meta property="og:see_also" content="https://jackcipher.github.io/posts/how-to-crack-shottr/"><meta name=twitter:card content="summary"><meta name=twitter:title content="逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法"><meta name=twitter:description content="
        一场有趣的猫鼠游戏：当开发者针对旧版破解方案引入了硬编码的校验逻辑，我们该如何层层剥茧，还原其背后的算法真相？
    0x01 前言在 8 月份的文章中，我分享了如何通过 mitmproxy 激活 Shottr。原本以为这只是一个简单的 HTTP 数据包篡改游戏，但作者在 v1.9.1 版本中打了一个「反击战」。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jackcipher.github.io/posts/"},{"@type":"ListItem","position":2,"name":"逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法","item":"https://jackcipher.github.io/posts/how-to-crack-shottr-v1.9/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法","name":"逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法","description":" 一场有趣的猫鼠游戏：当开发者针对旧版破解方案引入了硬编码的校验逻辑，我们该如何层层剥茧，还原其背后的算法真相？\n0x01 前言在 8 月份的文章中，我分享了如何通过 mitmproxy 激活 Shottr。原本以为这只是一个简单的 HTTP 数据包篡改游戏，但作者在 v1.9.1 版本中打了一个「反击战」。\n","keywords":["逆向工程","效率工具","macOS"],"articleBody":" 一场有趣的猫鼠游戏：当开发者针对旧版破解方案引入了硬编码的校验逻辑，我们该如何层层剥茧，还原其背后的算法真相？\n0x01 前言在 8 月份的文章中，我分享了如何通过 mitmproxy 激活 Shottr。原本以为这只是一个简单的 HTTP 数据包篡改游戏，但作者在 v1.9.1 版本中打了一个「反击战」。\n更新版本后，原本的 Mock 方案失效了。抓包发现 API 返回了一个全新的字段 ch2，其格式类似于 时间戳.Hash。如果不提供匹配的 Hash，客户端会抛出严重的 Integrity 校验错误。\n这不再是修改一个布尔值就能解决的问题。这是一次需要动用静态分析与动态追踪的深度逆向实战。\nIMPORTANT 本文仅供网络安全技术交流与学习，请支持正版软件。\n0x02 成果展示在深入枯燥的汇编代码之前，我们先来看看最终的破解成果。\n下面的截图，均采用破解后的 Shottr v1.9.1 完成的\n破解前破解前：License 验证失败\n破解后破解后：激活成功，显示 Pro 订阅\n0x03 初步摸底：隐藏在二进制中的密钥当我们尝试像以前那样伪造 tier 字段（会员等级）时，客户端报错了。观察网络请求，除了 verify.php 之外，并没有其他远程校验行为。\n结论很明确： 校验这个 ch2 Hash 的逻辑和所需的 Secret，全部硬编码在 Shottr 的二进制文件中。只要我们能在几万行汇编中定位到那段逻辑，算法就无所遁形。\n0x04 静态分析：定位验证入口 (radare2)我们使用 radare2 来探索 Shottr 的内心世界。\n寻找突破口首先，我们搜索 API 返回的关键字段名和可能的报错信息：\n1 2 # 搜索 ch2 及相关提示 r2 -q -c '/ ch2; / Integrity check failed' /Applications/Shottr.app/Contents/MacOS/Shottr 输出定位到了数据段中的字符串地址。\n追踪交叉引用 (X-Ref)找到字符串后，我们通过 axt 命令寻找是谁在引用这些字符串。最终我们将目光锁定在了函数 sym.func.1000e25e0 上。\n反汇编该函数，我们发现了决定性的逻辑分支：\n1 2 3 0x1000e2a3c bl sym.func.1000e7ae4 ; 核心验证函数调用 0x1000e2a40 tbnz w0, 0, 0x1000e2a4c ; 检查返回值是否为非零（即验证通过） 0x1000e2a44 ... ; 验证失败分支，加载 \"Integrity check failed\" 通过这一步，锁定了核心验证逻辑的起始地址：0x1000e7ae4。\n发现加密原语在这个验证函数周边，我们发现它频繁调用了 CC_SHA256。通过搜索加密函数的 X-Ref，我们还意外在地址 0x1001f3280 附近发现了一些长得像 Secret 的 16 位硬编码字符串。\n目前的战果：\n找到了验证函数入口。 确认了使用了 SHA256 算法。 拿到了几个可疑的 Secret。 难点： 静态分析很难看清 SHA256 输入字符串的精确拼接格式（比如有没有空格？先后顺序？）。\n0x05 动态追踪：窥察内存真相 (Frida)为了看清内存中生成的拼装字符串，我们需要在运行时「窃听」 CC_SHA256。\n绕过 Hardened RuntimeShottr 启用了 macOS 的 Hardened Runtime，这会阻止调试器。我们需要先给它脱掉这层「软甲」：\n1 2 3 # 移除签名并重新进行 Ad-hoc 签名 codesign --remove-signature /tmp/Shottr_debug.app/Contents/MacOS/Shottr codesign -s - /tmp/Shottr_debug.app/Contents/MacOS/Shottr 编写 Frida Hook 脚本我们使用 frida-trace 快速生成模版，并编写 Handler 打印 CC_SHA256 的第一个参数（即待计算的明文字符串）。\n1 2 3 4 5 6 7 8 // __handlers__/libcommonCrypto.dylib/CC_SHA256.js onEnter(log, args, state) { var dataPtr = args[0]; var dataLen = parseInt(args[1]); if (dataLen \u003c 500) { log(\"[CC_SHA256] Input: \" + dataPtr.readUtf8String(dataLen)); } } 触发验证运行 Frida，并在 Shottr 界面输入任意 License Key。惊喜出现了，Frida 捕获到了三次连续的哈希计算过程：\n第一波：License前缀 + SECRET_A → Hash1 第二波：License前缀 + Hash1 + \" \" + 当前时间戳 + \" \" + SECRET_B 第三波 (关键)：License前缀 + Hash1 + \" \" + ch2时间戳 + \" \" + tier + \" \" + SECRET_C 0x06 算法还原：最终的公式完整公式基于动态分析，还原出 ch2 验证算法：\n1 2 3 4 5 6 ch2 格式: timestamp.hash 验证过程: 1. hash1 = SHA256(license_prefix + SECRET1) 2. expected_hash = SHA256(license_prefix + hash1 + \" \" + timestamp + \" \" + tier + \" \" + SECRET3) 3. 比较 expected_hash 与 ch2 中的 hash 验证算法正确性编写 Go 程序验证：\n1 2 3 4 5 func calculateCh2Hash(licensePrefix, timestamp, tier string) string { hash1 := sha256Hex(licensePrefix + SECRET1) input := licensePrefix + hash1 + \" \" + timestamp + \" \" + tier + \" \" + SECRET3 return sha256Hex(input) } 用 Frida 捕获的数据验证：\n输入: license前缀=「1234」, timestamp=“1767014600”, tier=「free」 计算结果与 Frida 捕获的 hash 完全匹配 ✅ 这意味着什么？这意味着 Shottr 的安全性完全建立在 Secret 的私密性上。而既然 Secret 是硬编码在客户端的，对于逆向工程来说，它就是透明的。\n0x07 关键发现算法特点 双重哈希: 先计算 license 的基础 hash，再计算最终验证 hash 时间戳绑定: hash 包含时间戳，防止重放 等级绑定: hash 包含 tier，防止篡改等级 License 绑定: hash 包含 license 前缀 安全弱点 Secrets 硬编码: 所有 secret 都存储在客户端二进制中 算法可逆: 知道 secrets 后可以计算任意有效的 ch2 无证书固定: 可以进行中间人攻击 利用方式基于以上分析，可以实现：\n中间人攻击，动态计算并返回有效的 ch2 本地 patch，绕过验证检查 0x08 具和命令汇总radare2 常用命令 命令 说明 aaa 完整分析 / string 搜索字符串 axt @ addr 查找交叉引用 s addr 跳转到地址 pd N 反汇编 N 条指令 pdf 反汇编整个函数 ps @ addr 打印字符串 px N 打印 hex Frida 工作流程 绕过代码签名保护 使用 frida-trace 自动生成 handler 修改 handler 记录函数输入输出 触发目标功能，观察调用 分析数据，还原算法 0x09 总结与思考本次逆向经历可以总结为标准的 「四步走」 流程：\n步骤 动作 工具 目的 1. 侦察 抓包分析 API Charles 确定攻击面 (ch2 字段) 2. 定位 字符串搜索与交叉引用 radare2 找到二进制中的验证逻辑开关 3. 截获 Hook 加密函数 Frida 还原明文字符串的拼接格式 4. 攻克 算法编写与 Mock Go/Python 本地生成合法 Hash 完成破解 ","wordCount":"1955","inLanguage":"zh","datePublished":"2025-12-29T21:50:58Z","dateModified":"2025-12-29T21:50:58Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://jackcipher.github.io/posts/how-to-crack-shottr-v1.9/"},"publisher":{"@type":"Organization","name":"Jack","logo":{"@type":"ImageObject","url":"https://jackcipher.github.io/static/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&(document.body.classList.add("dark"),document.documentElement.setAttribute("data-theme","dark"))</script><header class=header><nav class=nav><div class=logo><a href=https://jackcipher.github.io/ accesskey=h title="Jack (Alt + H)">Jack</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><button id=menu-trigger aria-haspopup=menu aria-label="Menu Button">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><ul id=menu><li><a href=https://jackcipher.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://jackcipher.github.io/tags/ title=标签><span>标签</span></a></li><li class=dropdown><a href=https://jackcipher.github.io/series/ title=系列><span>系列</span>
<svg class="dropdown-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg></a><ul class=submenu><li><a href=https://jackcipher.github.io/series/leetcode/ title=LeetCode>LeetCode</a></li><li><a href=https://jackcipher.github.io/series/go-in-action/ title="Go In Action">Go In Action</a></li><li><a href=https://jackcipher.github.io/series/devops/ title=DevOps>DevOps</a></li></ul></li><li><a href=https://jackcipher.github.io/about/ title=关于><span>关于</span></a></li></ul></nav><script>document.getElementById("menu-trigger").addEventListener("click",function(){document.body.classList.toggle("mobile-menu-active"),this.classList.toggle("is-active")})</script></header><div class=scroll-wrapper><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法</h1><div class=post-meta><span title='2025-12-29 21:50:58 +0000 UTC'>2025-12-29</span>&nbsp;·&nbsp;<span>4 分钟</span></div></header><div class=post-series><div class=series-header onclick='this.parentElement.classList.toggle("expanded")'><h2 class=series-title>系列：<a href=/series/shottr/ onclick=event.stopPropagation()>Shottr</a></h2><span class=series-toggle-icon><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="20" height="20"><polyline points="6 9 12 15 18 9"/></svg></span></div><div class=series-posts><ul class=series-list><li class=series-item><a href=https://jackcipher.github.io/posts/how-to-crack-shottr/ class=series-item-link>如何通过 mitmproxy 激活 Shottr</a></li><li class="series-item active"><span class=series-item-title>逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法</span></li></ul></div></div><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><div class=item><div class=circle></div><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></div></li><li><div class=item><div class=circle></div><a href=#%e6%88%90%e6%9e%9c%e5%b1%95%e7%a4%ba aria-label=成果展示>成果展示</a></div></li><li><div class=item><div class=circle></div><a href=#%e5%88%9d%e6%ad%a5%e6%91%b8%e5%ba%95%e9%9a%90%e8%97%8f%e5%9c%a8%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%b8%ad%e7%9a%84%e5%af%86%e9%92%a5 aria-label=初步摸底：隐藏在二进制中的密钥>初步摸底：隐藏在二进制中的密钥</a></div></li><li><div class=item><div class=circle></div><a href=#%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90%e5%ae%9a%e4%bd%8d%e9%aa%8c%e8%af%81%e5%85%a5%e5%8f%a3-radare2 aria-label="静态分析：定位验证入口 (radare2)">静态分析：定位验证入口 (radare2)</a></div></li><li><div class=item><div class=circle></div><a href=#%e5%8a%a8%e6%80%81%e8%bf%bd%e8%b8%aa%e7%aa%a5%e5%af%9f%e5%86%85%e5%ad%98%e7%9c%9f%e7%9b%b8-frida aria-label="动态追踪：窥察内存真相 (Frida)">动态追踪：窥察内存真相 (Frida)</a></div></li><li><div class=item><div class=circle></div><a href=#%e7%ae%97%e6%b3%95%e8%bf%98%e5%8e%9f%e6%9c%80%e7%bb%88%e7%9a%84%e5%85%ac%e5%bc%8f aria-label=算法还原：最终的公式>算法还原：最终的公式</a></div></li><li><div class=item><div class=circle></div><a href=#%e5%85%b3%e9%94%ae%e5%8f%91%e7%8e%b0 aria-label=关键发现>关键发现</a></div></li><li><div class=item><div class=circle></div><a href=#%e5%85%b7%e5%92%8c%e5%91%bd%e4%bb%a4%e6%b1%87%e6%80%bb aria-label=具和命令汇总>具和命令汇总</a></div></li><li><div class=item><div class=circle></div><a href=#%e6%80%bb%e7%bb%93%e4%b8%8e%e6%80%9d%e8%80%83 aria-label=总结与思考>总结与思考</a></div></li></ul></div></div></aside><script>const tocMaxLevel=2;let activeElement,allHeadings,tocHeadings;window.addEventListener("DOMContentLoaded",function(){history.scrollRestoration&&(history.scrollRestoration="manual"),checkTocPosition(),allHeadings=document.querySelectorAll("h2[id],h3[id],h4[id],h5[id],h6[id]");const n=Array.from({length:tocMaxLevel-1},(e,t)=>`h${t+2}[id]`).join(",");tocHeadings=document.querySelectorAll(n);const s=document.querySelector(".scroll-wrapper")||window,t=document.querySelector(".post-content");activeElement=null,s.addEventListener("scroll",()=>{if(!t)return;const s=t.getBoundingClientRect(),e=window.innerHeight;if(s.top>e/2){activeElement=null,clearActiveStates();return}if(s.bottom<e/2){activeElement=null,clearActiveStates();return}const o=e/2,n=Array.from(allHeadings).filter(e=>{const t=e.getBoundingClientRect();return t.top<o});n.length>0?activeElement=n[n.length-1]:activeElement=null,updateActiveStates()},!1)},!1),window.addEventListener("resize",function(){checkTocPosition()},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc-gap*12>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function findTocTarget(e){if(!e)return null;const n=parseInt(e.tagName[1]);if(n<=tocMaxLevel)return e;const t=Array.from(allHeadings),s=t.indexOf(e);for(let e=s-1;e>=0;e--){const n=parseInt(t[e].tagName[1]);if(n<=tocMaxLevel)return t[e]}return null}function clearActiveStates(){tocHeadings.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`)?.classList.remove("active"),document.querySelector(`.inner ul li .item:has(a[href="#${t}"])`)?.classList.remove("active")})}function updateActiveStates(){const e=findTocTarget(activeElement);tocHeadings.forEach(t=>{const n=encodeURI(t.getAttribute("id")).toLowerCase();t===e?(document.querySelector(`.inner ul li a[href="#${n}"]`)?.classList.add("active"),document.querySelector(`.inner ul li .item:has(a[href="#${n}"])`)?.classList.add("active")):(document.querySelector(`.inner ul li a[href="#${n}"]`)?.classList.remove("active"),document.querySelector(`.inner ul li .item:has(a[href="#${n}"])`)?.classList.remove("active"))})}</script><div class=post-content><blockquote><p>一场有趣的猫鼠游戏：当开发者针对旧版破解方案引入了硬编码的校验逻辑，我们该如何层层剥茧，还原其背后的算法真相？</p></blockquote><h2 id=前言>0x01 前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>在 8 月份的文章中，我分享了<a href=https://jackcipher.github.io/posts/how-to-crack-shottr/>如何通过 mitmproxy 激活 Shottr</a>。原本以为这只是一个简单的 HTTP 数据包篡改游戏，但作者在 v1.9.1 版本中打了一个「反击战」。</p><p>更新版本后，原本的 Mock 方案失效了。抓包发现 API 返回了一个全新的字段 <code>ch2</code>，其格式类似于 <code>时间戳.Hash</code>。如果不提供匹配的 Hash，客户端会抛出严重的 Integrity 校验错误。</p><p>这不再是修改一个布尔值就能解决的问题。这是一次需要动用<strong>静态分析</strong>与<strong>动态追踪</strong>的深度逆向实战。</p><div class="callout callout-purple"><div class=callout-header><span class=callout-icon><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8.5 14.5A2.5 2.5.0 0011 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5s3 3.5 3 5.5A7 7 0 115 15c0-1.153.433-2.294 1-3a2.5 2.5.0 002.5 2.5z"/></svg></span>
<span class=callout-title>IMPORTANT</span></div><div class=callout-content><p>本文仅供网络安全技术交流与学习，请支持正版软件。</p></div></div><h2 id=成果展示>0x02 成果展示<a hidden class=anchor aria-hidden=true href=#成果展示>#</a></h2><p>在深入枯燥的汇编代码之前，我们先来看看最终的破解成果。</p><blockquote><p>下面的截图，均采用破解后的 Shottr v1.9.1 完成的</p></blockquote><h3 id=破解前>破解前<a hidden class=anchor aria-hidden=true href=#破解前>#</a></h3><p>破解前：License 验证失败</p><p><img alt="破解前：License 验证失败" loading=lazy src=https://cdn.jsdelivr.net/gh/jackcipher/static_resource@master/imgs/obsidian/20251229220542260.png></p><h3 id=破解后>破解后<a hidden class=anchor aria-hidden=true href=#破解后>#</a></h3><p>破解后：激活成功，显示 Pro 订阅</p><p><img alt="破解后：激活成功，显示 Pro 订阅" loading=lazy src=https://cdn.jsdelivr.net/gh/jackcipher/static_resource@master/imgs/obsidian/20251229221313709.png></p><h2 id=初步摸底隐藏在二进制中的密钥>0x03 初步摸底：隐藏在二进制中的密钥<a hidden class=anchor aria-hidden=true href=#初步摸底隐藏在二进制中的密钥>#</a></h2><p>当我们尝试像以前那样伪造 <code>tier</code> 字段（会员等级）时，客户端报错了。观察网络请求，除了 <code>verify.php</code> 之外，并没有其他远程校验行为。</p><p><strong>结论很明确：</strong> 校验这个 <code>ch2</code> Hash 的逻辑和所需的 Secret，全部硬编码在 Shottr 的二进制文件中。只要我们能在几万行汇编中定位到那段逻辑，算法就无所遁形。</p><h2 id=静态分析定位验证入口-radare2>0x04 静态分析：定位验证入口 (radare2)<a hidden class=anchor aria-hidden=true href=#静态分析定位验证入口-radare2>#</a></h2><p>我们使用 <code>radare2</code> 来探索 Shottr 的内心世界。</p><h3 id=寻找突破口>寻找突破口<a hidden class=anchor aria-hidden=true href=#寻找突破口>#</a></h3><p>首先，我们搜索 API 返回的关键字段名和可能的报错信息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 搜索 ch2 及相关提示</span>
</span></span><span class=line><span class=cl>r2 -q -c <span class=s1>&#39;/ ch2; / Integrity check failed&#39;</span> /Applications/Shottr.app/Contents/MacOS/Shottr
</span></span></code></pre></td></tr></table></div></div><p>输出定位到了数据段中的字符串地址。</p><h3 id=追踪交叉引用-x-ref>追踪交叉引用 (X-Ref)<a hidden class=anchor aria-hidden=true href=#追踪交叉引用-x-ref>#</a></h3><p>找到字符串后，我们通过 <code>axt</code> 命令寻找是谁在引用这些字符串。最终我们将目光锁定在了函数 <code>sym.func.1000e25e0</code> 上。</p><p>反汇编该函数，我们发现了决定性的逻辑分支：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>0</span><span class=nf>x1000e2a3c</span>    <span class=no>bl</span> <span class=no>sym.func.1000e7ae4</span>    <span class=c1>; 核心验证函数调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>0</span><span class=nf>x1000e2a40</span>    <span class=no>tbnz</span> <span class=no>w0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0x1000e2a4c</span>  <span class=c1>; 检查返回值是否为非零（即验证通过）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>0</span><span class=nf>x1000e2a44</span>    <span class=no>...</span>                      <span class=c1>; 验证失败分支，加载 &#34;Integrity check failed&#34;
</span></span></span></code></pre></td></tr></table></div></div><p>通过这一步，锁定了<strong>核心验证逻辑</strong>的起始地址：<code>0x1000e7ae4</code>。</p><h3 id=发现加密原语>发现加密原语<a hidden class=anchor aria-hidden=true href=#发现加密原语>#</a></h3><p>在这个验证函数周边，我们发现它频繁调用了 <code>CC_SHA256</code>。通过搜索加密函数的 X-Ref，我们还意外在地址 <code>0x1001f3280</code> 附近发现了一些长得像 Secret 的 16 位硬编码字符串。</p><p><strong>目前的战果：</strong></p><ul><li>找到了验证函数入口。</li><li>确认了使用了 SHA256 算法。</li><li>拿到了几个可疑的 Secret。</li></ul><p><strong>难点：</strong> 静态分析很难看清 SHA256 输入字符串的<strong>精确拼接格式</strong>（比如有没有空格？先后顺序？）。</p><h2 id=动态追踪窥察内存真相-frida>0x05 动态追踪：窥察内存真相 (Frida)<a hidden class=anchor aria-hidden=true href=#动态追踪窥察内存真相-frida>#</a></h2><p>为了看清内存中生成的拼装字符串，我们需要在运行时「窃听」 <code>CC_SHA256</code>。</p><h3 id=绕过-hardened-runtime>绕过 Hardened Runtime<a hidden class=anchor aria-hidden=true href=#绕过-hardened-runtime>#</a></h3><p>Shottr 启用了 macOS 的 Hardened Runtime，这会阻止调试器。我们需要先给它脱掉这层「软甲」：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 移除签名并重新进行 Ad-hoc 签名</span>
</span></span><span class=line><span class=cl>codesign --remove-signature /tmp/Shottr_debug.app/Contents/MacOS/Shottr
</span></span><span class=line><span class=cl>codesign -s - /tmp/Shottr_debug.app/Contents/MacOS/Shottr
</span></span></code></pre></td></tr></table></div></div><h3 id=编写-frida-hook-脚本>编写 Frida Hook 脚本<a hidden class=anchor aria-hidden=true href=#编写-frida-hook-脚本>#</a></h3><p>我们使用 <code>frida-trace</code> 快速生成模版，并编写 Handler 打印 <code>CC_SHA256</code> 的第一个参数（即待计算的明文字符串）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// __handlers__/libcommonCrypto.dylib/CC_SHA256.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>onEnter</span><span class=p>(</span><span class=nx>log</span><span class=p>,</span> <span class=nx>args</span><span class=p>,</span> <span class=nx>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>dataPtr</span> <span class=o>=</span> <span class=nx>args</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>dataLen</span> <span class=o>=</span> <span class=nb>parseInt</span><span class=p>(</span><span class=nx>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>dataLen</span> <span class=o>&lt;</span> <span class=mi>500</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>(</span><span class=s2>&#34;[CC_SHA256] Input: &#34;</span> <span class=o>+</span> <span class=nx>dataPtr</span><span class=p>.</span><span class=nx>readUtf8String</span><span class=p>(</span><span class=nx>dataLen</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=触发验证>触发验证<a hidden class=anchor aria-hidden=true href=#触发验证>#</a></h3><p>运行 Frida，并在 Shottr 界面输入任意 License Key。惊喜出现了，Frida 捕获到了三次连续的哈希计算过程：</p><ol><li><strong>第一波</strong>：<code>License前缀 + SECRET_A</code> → <code>Hash1</code></li><li><strong>第二波</strong>：<code>License前缀 + Hash1 + " " + 当前时间戳 + " " + SECRET_B</code></li><li><strong>第三波 (关键)</strong>：<code>License前缀 + Hash1 + " " + ch2时间戳 + " " + tier + " " + SECRET_C</code></li></ol><h2 id=算法还原最终的公式>0x06 算法还原：最终的公式</h2><h3 id=完整公式>完整公式<a hidden class=anchor aria-hidden=true href=#算法还原最终的公式>#</a></h3><p>基于动态分析，还原出 ch2 验证算法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ch2 格式: timestamp.hash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>验证过程:
</span></span><span class=line><span class=cl>1. hash1 = SHA256(license_prefix + SECRET1)
</span></span><span class=line><span class=cl>2. expected_hash = SHA256(license_prefix + hash1 + &#34; &#34; + timestamp + &#34; &#34; + tier + &#34; &#34; + SECRET3)
</span></span><span class=line><span class=cl>3. 比较 expected_hash 与 ch2 中的 hash
</span></span></code></pre></td></tr></table></div></div><h3 id=验证算法正确性>验证算法正确性<a hidden class=anchor aria-hidden=true href=#验证算法正确性>#</a></h3><p>编写 Go 程序验证：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>calculateCh2Hash</span><span class=p>(</span><span class=nx>licensePrefix</span><span class=p>,</span><span class=w> </span><span class=nx>timestamp</span><span class=p>,</span><span class=w> </span><span class=nx>tier</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>hash1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>sha256Hex</span><span class=p>(</span><span class=nx>licensePrefix</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>SECRET1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>input</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>licensePrefix</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>hash1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>timestamp</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>tier</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>SECRET3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nf>sha256Hex</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>用 Frida 捕获的数据验证：</p><ul><li>输入: license前缀=「1234」, timestamp=&ldquo;1767014600&rdquo;, tier=「free」</li><li>计算结果与 Frida 捕获的 hash <strong>完全匹配</strong> ✅</li></ul><p>这意味着什么？这意味着 Shottr 的安全性完全建立在 Secret 的私密性上。而既然 Secret 是硬编码在客户端的，对于逆向工程来说，它就是透明的。</p><h2 id=关键发现>0x07 关键发现</h2><h3 id=算法特点>算法特点<a hidden class=anchor aria-hidden=true href=#关键发现>#</a></h3><ol><li><strong>双重哈希</strong>: 先计算 license 的基础 hash，再计算最终验证 hash</li><li><strong>时间戳绑定</strong>: hash 包含时间戳，防止重放</li><li><strong>等级绑定</strong>: hash 包含 tier，防止篡改等级</li><li><strong>License 绑定</strong>: hash 包含 license 前缀</li></ol><h3 id=安全弱点>安全弱点<a hidden class=anchor aria-hidden=true href=#安全弱点>#</a></h3><ol><li><strong>Secrets 硬编码</strong>: 所有 secret 都存储在客户端二进制中</li><li><strong>算法可逆</strong>: 知道 secrets 后可以计算任意有效的 ch2</li><li><strong>无证书固定</strong>: 可以进行中间人攻击</li></ol><h3 id=利用方式>利用方式<a hidden class=anchor aria-hidden=true href=#利用方式>#</a></h3><p>基于以上分析，可以实现：</p><ol><li>中间人攻击，动态计算并返回有效的 ch2</li><li>本地 patch，绕过验证检查</li></ol><hr><h2 id=具和命令汇总>0x08 具和命令汇总</h2><h3 id=radare2-常用命令>radare2 常用命令<a hidden class=anchor aria-hidden=true href=#具和命令汇总>#</a></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>aaa</code></td><td>完整分析</td></tr><tr><td><code>/ string</code></td><td>搜索字符串</td></tr><tr><td><code>axt @ addr</code></td><td>查找交叉引用</td></tr><tr><td><code>s addr</code></td><td>跳转到地址</td></tr><tr><td><code>pd N</code></td><td>反汇编 N 条指令</td></tr><tr><td><code>pdf</code></td><td>反汇编整个函数</td></tr><tr><td><code>ps @ addr</code></td><td>打印字符串</td></tr><tr><td><code>px N</code></td><td>打印 hex</td></tr></tbody></table><h3 id=frida-工作流程>Frida 工作流程<a hidden class=anchor aria-hidden=true href=#frida-工作流程>#</a></h3><ol><li>绕过代码签名保护</li><li>使用 frida-trace 自动生成 handler</li><li>修改 handler 记录函数输入输出</li><li>触发目标功能，观察调用</li><li>分析数据，还原算法</li></ol><h2 id=总结与思考>0x09 总结与思考<a hidden class=anchor aria-hidden=true href=#总结与思考>#</a></h2><p>本次逆向经历可以总结为标准的 <strong>「四步走」</strong> 流程：</p><table><thead><tr><th>步骤</th><th>动作</th><th>工具</th><th>目的</th></tr></thead><tbody><tr><td><strong>1. 侦察</strong></td><td>抓包分析 API</td><td>Charles</td><td>确定攻击面 (<code>ch2</code> 字段)</td></tr><tr><td><strong>2. 定位</strong></td><td>字符串搜索与交叉引用</td><td>radare2</td><td>找到二进制中的验证逻辑开关</td></tr><tr><td><strong>3. 截获</strong></td><td>Hook 加密函数</td><td>Frida</td><td>还原明文字符串的拼接格式</td></tr><tr><td><strong>4. 攻克</strong></td><td>算法编写与 Mock</td><td>Go/Python</td><td>本地生成合法 Hash 完成破解</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://jackcipher.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/>逆向工程</a></li><li><a href=https://jackcipher.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/>效率工具</a></li><li><a href=https://jackcipher.github.io/tags/macos/>MacOS</a></li></ul><nav class=paginav><a class=next href=https://jackcipher.github.io/posts/ffmpeg-snapshot-performance/><span class=title>下一页 »</span>
<span>FFmpeg 参数顺序的隐藏陷阱</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法 on x" href="https://x.com/intent/tweet/?text=%e9%80%86%e5%90%91%e5%b7%a5%e5%85%b7%e5%ae%9e%e6%88%98%ef%bc%9a%e8%bf%98%e5%8e%9f%20Shottr%20v1.9.1%20%e7%9a%84%20Hash%20%e7%ae%97%e6%b3%95&amp;url=https%3a%2f%2fjackcipher.github.io%2fposts%2fhow-to-crack-shottr-v1.9%2f&amp;hashtags=%e9%80%86%e5%90%91%e5%b7%a5%e7%a8%8b%2c%e6%95%88%e7%8e%87%e5%b7%a5%e5%85%b7%2cmacOS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjackcipher.github.io%2fposts%2fhow-to-crack-shottr-v1.9%2f&amp;title=%e9%80%86%e5%90%91%e5%b7%a5%e5%85%b7%e5%ae%9e%e6%88%98%ef%bc%9a%e8%bf%98%e5%8e%9f%20Shottr%20v1.9.1%20%e7%9a%84%20Hash%20%e7%ae%97%e6%b3%95&amp;summary=%e9%80%86%e5%90%91%e5%b7%a5%e5%85%b7%e5%ae%9e%e6%88%98%ef%bc%9a%e8%bf%98%e5%8e%9f%20Shottr%20v1.9.1%20%e7%9a%84%20Hash%20%e7%ae%97%e6%b3%95&amp;source=https%3a%2f%2fjackcipher.github.io%2fposts%2fhow-to-crack-shottr-v1.9%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjackcipher.github.io%2fposts%2fhow-to-crack-shottr-v1.9%2f&title=%e9%80%86%e5%90%91%e5%b7%a5%e5%85%b7%e5%ae%9e%e6%88%98%ef%bc%9a%e8%bf%98%e5%8e%9f%20Shottr%20v1.9.1%20%e7%9a%84%20Hash%20%e7%ae%97%e6%b3%95"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjackcipher.github.io%2fposts%2fhow-to-crack-shottr-v1.9%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法 on whatsapp" href="https://api.whatsapp.com/send?text=%e9%80%86%e5%90%91%e5%b7%a5%e5%85%b7%e5%ae%9e%e6%88%98%ef%bc%9a%e8%bf%98%e5%8e%9f%20Shottr%20v1.9.1%20%e7%9a%84%20Hash%20%e7%ae%97%e6%b3%95%20-%20https%3a%2f%2fjackcipher.github.io%2fposts%2fhow-to-crack-shottr-v1.9%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法 on telegram" href="https://telegram.me/share/url?text=%e9%80%86%e5%90%91%e5%b7%a5%e5%85%b7%e5%ae%9e%e6%88%98%ef%bc%9a%e8%bf%98%e5%8e%9f%20Shottr%20v1.9.1%20%e7%9a%84%20Hash%20%e7%ae%97%e6%b3%95&amp;url=https%3a%2f%2fjackcipher.github.io%2fposts%2fhow-to-crack-shottr-v1.9%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 逆向工具实战：还原 Shottr v1.9.1 的 Hash 算法 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e9%80%86%e5%90%91%e5%b7%a5%e5%85%b7%e5%ae%9e%e6%88%98%ef%bc%9a%e8%bf%98%e5%8e%9f%20Shottr%20v1.9.1%20%e7%9a%84%20Hash%20%e7%ae%97%e6%b3%95&u=https%3a%2f%2fjackcipher.github.io%2fposts%2fhow-to-crack-shottr-v1.9%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><style>.utterances{border-radius:var(--radius);transition:height .3s}</style><div id=comments></div><script>function createUtterancesEl(){const e=document.createElement("script");return e.src="https://utteranc.es/client.js",e.setAttribute("repo","jackcipher/blog-comments"),e.setAttribute("issue-term","pathname"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.body.className.includes("dark")?e.setAttribute("theme","github-dark"):e.setAttribute("theme","github-light"),e}const commentsContainer=document.getElementById("comments");commentsContainer&&commentsContainer.appendChild(createUtterancesEl());const themeToggle=document.querySelector("#theme-toggle");themeToggle&&themeToggle.addEventListener("click",()=>{setTimeout(()=>{const t=document.body.className.includes("dark"),n=t?"github-dark":"github-light",e=document.querySelector(".utterances-frame");if(e){const t={type:"set-theme",theme:n};e.contentWindow.postMessage(t,"https://utteranc.es")}},100)})</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://jackcipher.github.io/>Jack</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>document.addEventListener("DOMContentLoaded",function(){setTimeout(e,100);function e(){let e=document.querySelector(".lightbox-overlay");e||(e=document.createElement("div"),e.className="lightbox-overlay",e.innerHTML=`
                <button class="lightbox-close" aria-label="关闭">×</button>
                <div class="lightbox-hint">滚轮缩放 · 拖拽移动 · 双击重置</div>
                <div class="lightbox-zoomable fit-screen">
                    <div class="lightbox-content"></div>
                </div>
                <div class="lightbox-controls">
                    <button class="zoom-out" aria-label="缩小">−</button>
                    <span class="lightbox-zoom-level">100%</span>
                    <button class="zoom-in" aria-label="放大">+</button>
                    <button class="zoom-reset" aria-label="重置">⟲</button>
                </div>
                <div class="lightbox-caption"></div>
            `,document.body.appendChild(e));let n=e.querySelector(".lightbox-zoomable"),s=e.querySelector(".lightbox-content");n||(n=document.createElement("div"),n.className="lightbox-zoomable fit-screen",e.appendChild(n)),s||(s=document.createElement("div"),s.className="lightbox-content",n.appendChild(s));const O=e.querySelector(".lightbox-close"),h=e.querySelector(".lightbox-caption"),j=e.querySelector(".lightbox-zoom-level"),m=e.querySelector(".zoom-in"),_=e.querySelector(".zoom-out"),f=e.querySelector(".zoom-reset"),u=e.querySelector(".lightbox-hint");let t=1,i=0,o=0,l=!1,y=0,p=0,g=0,v=0;const x=.5,w=5,r=.25;function d(){n.style.transform=`translate(${i}px, ${o}px) scale(${t})`,j&&(j.textContent=Math.round(t*100)+"%"),t<=1?(n.classList.add("fit-screen"),n.classList.remove("zoomed")):(n.classList.remove("fit-screen"),n.classList.add("zoomed"))}function c(){t=1,i=0,o=0,d()}function a(n,s,a){if(n=Math.max(x,Math.min(w,n)),s!==0[0]&&a!==0[0]){const r=e.getBoundingClientRect(),c=s-r.width/2,l=a-r.height/2,d=n/t;i=c-(c-i)*d,o=l-(l-o)*d}t=n,t<=1&&(i=0,o=0),d()}function b(){e.classList.remove("active"),document.body.style.overflow="",c(),s.innerHTML="";const t=e.querySelector("img");t&&(t.style.display="")}function C(t){const o=t.querySelector("svg");if(!o)return;const i=e.querySelector(".lightbox-zoomable > img");i&&(i.style.display="none");const n=o.cloneNode(!0),a=o.getAttribute("viewBox");if(a){const e=a.split(" "),t=parseFloat(e[2]),s=parseFloat(e[3]),i=window.innerWidth*.85,r=window.innerHeight*.75,o=Math.min(i/t,r/s,1.5);n.style.width=t*o+"px",n.style.height=s*o+"px"}else{const e=o.getBoundingClientRect();n.style.width=e.width+"px",n.style.height=e.height+"px"}n.style.background="white",n.style.borderRadius="8px",n.style.padding="20px",n.style.boxShadow="0 20px 60px rgba(0, 0, 0, 0.5)",s.innerHTML="",s.appendChild(n),h&&(h.textContent="Mermaid 图表",h.style.display="block"),u&&(u.classList.remove("hidden"),setTimeout(()=>u.classList.add("hidden"),3e3)),e.classList.add("active"),document.body.style.overflow="hidden"}e.addEventListener("wheel",n=>{if(!e.classList.contains("active"))return;if(!s.querySelector("svg"))return;n.preventDefault();const o=n.deltaY>0?-r:r;a(t+o,n.clientX,n.clientY)},{passive:!1}),n.addEventListener("mousedown",e=>{if(!s.querySelector("svg"))return;if(t<=1)return;l=!0,n.classList.add("dragging"),y=e.clientX,p=e.clientY,g=i,v=o,e.preventDefault()}),document.addEventListener("mousemove",e=>{if(!l)return;if(!s.querySelector("svg"))return;i=g+(e.clientX-y),o=v+(e.clientY-p),d()}),document.addEventListener("mouseup",()=>{l&&(l=!1,n.classList.remove("dragging"))}),n.addEventListener("dblclick",e=>{if(!s.querySelector("svg"))return;t>1?c():a(2,e.clientX,e.clientY)}),m&&m.addEventListener("click",()=>a(t+r)),_&&_.addEventListener("click",()=>a(t-r)),f&&f.addEventListener("click",c),e.addEventListener("click",t=>{(t.target===e||t.target===O)&&b()}),document.addEventListener("keydown",n=>{if(!e.classList.contains("active"))return;if(!s.querySelector("svg"))return;n.key==="Escape"?t>1?c():b():n.key==="+"||n.key==="="?a(t+r):n.key==="-"?a(t-r):n.key==="0"&&c()});const E=document.querySelectorAll(".post-content .mermaid");E.forEach(function(e){const t=setInterval(function(){e.getAttribute("data-processed")&&(clearInterval(t),e.classList.add("mermaid-zoomable"),e.addEventListener("click",function(t){t.preventDefault(),t.stopPropagation(),C(e)}))},200)})}})</script><script>(function(){const t=document.querySelectorAll(".post-entry, .archive-entry");if(!t.length)return;document.body.classList.add("animate-ready");let e=0;const s=5,n=new IntersectionObserver(t=>{t.forEach(t=>{if(t.isIntersecting){const o=t.target;e<s&&(o.style.animationDelay=`${e*.06}s`,e++),o.classList.add("animate-in"),o.addEventListener("animationend",()=>{o.classList.add("animate-done")},{once:!0}),n.unobserve(o)}})},{threshold:.05,rootMargin:"0px"});t.forEach(e=>n.observe(e))})()</script><script>(function(){const t=document.getElementById("reading-progress");if(!t)return;const e=document.querySelector(".scroll-wrapper");if(!e)return;let n=!1;function s(){const o=e.scrollTop,s=e.scrollHeight-e.clientHeight;if(s>0){const e=o/s*100;t.style.width=Math.min(e,100)+"%",e>=99?t.classList.add("complete"):t.classList.remove("complete")}n=!1}e.addEventListener("scroll",function(){n||(requestAnimationFrame(s),n=!0)},{passive:!0}),s()})()</script><script>(function(){document.querySelectorAll(".copy-code").forEach(e=>{e.addEventListener("click",function(){this.classList.add("copied"),setTimeout(()=>{this.classList.remove("copied")},1500)})});const e=document.getElementById("theme-toggle");e&&e.addEventListener("click",function(){this.classList.add("switching"),setTimeout(()=>{this.classList.remove("switching")},500)}),document.querySelectorAll(".post-entry").forEach(e=>{e.addEventListener("click",function(e){const t=document.createElement("span");t.classList.add("ripple");const n=this.getBoundingClientRect(),s=Math.max(n.width,n.height);t.style.width=t.style.height=s+"px",t.style.left=e.clientX-n.left-s/2+"px",t.style.top=e.clientY-n.top-s/2+"px",this.appendChild(t),setTimeout(()=>t.remove(),600)})})})()</script><script>(function(){const j=document.querySelector(".post-content");if(!j)return;const e=document.createElement("div");e.className="lightbox-overlay",e.innerHTML=`
        <button class="lightbox-close" aria-label="关闭">×</button>
        <div class="lightbox-hint">滚轮缩放 · 拖拽移动 · 双击重置</div>
        <div class="lightbox-zoomable fit-screen">
            <img src="" alt="">
        </div>
        <div class="lightbox-controls">
            <button class="zoom-out" aria-label="缩小">−</button>
            <span class="lightbox-zoom-level">100%</span>
            <button class="zoom-in" aria-label="放大">+</button>
            <button class="zoom-reset" aria-label="重置">⟲</button>
        </div>
        <div class="lightbox-caption"></div>
    `,document.body.appendChild(e);const n=e.querySelector(".lightbox-zoomable"),f=e.querySelector("img"),p=e.querySelector(".lightbox-caption"),C=e.querySelector(".lightbox-close"),w=e.querySelector(".lightbox-zoom-level"),x=e.querySelector(".zoom-in"),A=e.querySelector(".zoom-out"),O=e.querySelector(".zoom-reset"),b=e.querySelector(".lightbox-hint");let t=1,o=0,s=0,a=!1,d=0,h=0,m=0,l=0;const E=.5,k=5,r=.25;function u(){n.style.transform=`translate(${o}px, ${s}px) scale(${t})`,w.textContent=Math.round(t*100)+"%",t<=1?(n.classList.add("fit-screen"),n.classList.remove("zoomed")):(n.classList.remove("fit-screen"),n.classList.add("zoomed"))}function c(){t=1,o=0,s=0,u()}function i(n,i,a){if(n=Math.max(E,Math.min(k,n)),i!==0[0]&&a!==0[0]){const r=e.getBoundingClientRect(),c=i-r.width/2,l=a-r.height/2,d=n/t;o=c-(c-o)*d,s=l-(l-s)*d}t=n,t<=1&&(o=0,s=0),u()}function g(){e.classList.remove("active"),document.body.style.overflow="",c()}function _(t,n){f.src=t.src,f.alt=t.alt,f.onload=function(){const s=window.innerWidth*.9,o=window.innerHeight*.8,i=Math.max(this.naturalWidth||0,n?.width||0),a=Math.max(this.naturalHeight||0,n?.height||0),e=i||s*.5,t=a||o*.5;if(e>s||t>o){const i=s/e,a=o/t,n=Math.min(i,a);this.style.width=e*n+"px",this.style.height=t*n+"px"}else this.style.width=e+"px",this.style.height=t+"px"};const o=t.closest("figure")?.querySelector("figcaption"),s=o?.textContent||t.alt;p.textContent=s,p.style.display=s?"block":"none",e.classList.add("active"),document.body.style.overflow="hidden",b.classList.remove("hidden"),setTimeout(()=>b.classList.add("hidden"),3e3)}j.addEventListener("click",e=>{const t=e.target.closest("img");if(!t)return;if(t.closest(".mermaid"))return;const n=t.getBoundingClientRect();if(n.width<50||n.height<50)return;e.preventDefault(),e.stopPropagation(),_(t,{width:n.width,height:n.height})}),e.addEventListener("wheel",n=>{if(!e.classList.contains("active"))return;n.preventDefault();const s=n.deltaY>0?-r:r;i(t+s,n.clientX,n.clientY)},{passive:!1}),n.addEventListener("mousedown",e=>{if(t<=1)return;a=!0,n.classList.add("dragging"),d=e.clientX,h=e.clientY,m=o,l=s,e.preventDefault()}),document.addEventListener("mousemove",e=>{if(!a)return;o=m+(e.clientX-d),s=l+(e.clientY-h),u()}),document.addEventListener("mouseup",()=>{a&&(a=!1,n.classList.remove("dragging"))}),n.addEventListener("dblclick",e=>{t>1?c():i(2,e.clientX,e.clientY)}),x.addEventListener("click",()=>i(t+r)),A.addEventListener("click",()=>i(t-r)),O.addEventListener("click",c),e.addEventListener("click",t=>{(t.target===e||t.target===C)&&g()}),document.addEventListener("keydown",n=>{if(!e.classList.contains("active"))return;n.key==="Escape"?t>1?c():g():n.key==="+"||n.key==="="?i(t+r):n.key==="-"?i(t-r):n.key==="0"&&c()});let y=0,v=1;n.addEventListener("touchstart",e=>{e.touches.length===2?(y=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY),v=t):e.touches.length===1&&t>1&&(a=!0,d=e.touches[0].clientX,h=e.touches[0].clientY,m=o,l=s)},{passive:!0}),n.addEventListener("touchmove",e=>{if(e.touches.length===2){e.preventDefault();const t=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY),n=(e.touches[0].clientX+e.touches[1].clientX)/2,s=(e.touches[0].clientY+e.touches[1].clientY)/2;i(v*(t/y),n,s)}else a&&e.touches.length===1&&(o=m+(e.touches[0].clientX-d),s=l+(e.touches[0].clientY-h),u())},{passive:!1}),n.addEventListener("touchend",()=>{a=!1}),window.openImageLightbox=_,window.lightboxOverlay=e})()</script><script>(function(){function a(){const e=document.createElement("div");e.className="confetti-container",document.body.appendChild(e);const t=["#f093fb","#f5576c","#667eea","#764ba2","#ffd700","#00d4ff"],n=["circle","square","ribbon"];for(let o=0;o<100;o++){const s=document.createElement("div");s.className="confetti "+n[Math.floor(Math.random()*n.length)],s.style.left=Math.random()*100+"vw",s.style.background=t[Math.floor(Math.random()*t.length)],s.style.animationDelay=Math.random()*2+"s",s.style.animationDuration=2+Math.random()*2+"s",e.appendChild(s)}setTimeout(()=>e.remove(),5e3)}function r(){const e=["🎉","🚀","✨","🎊","💫","⭐","🌟","💖","🔥","🎈"];for(let t=0;t<30;t++)setTimeout(()=>{const t=document.createElement("span");t.className="emoji-rain",t.textContent=e[Math.floor(Math.random()*e.length)],t.style.left=Math.random()*100+"vw",t.style.top="-50px",t.style.fontSize=16+Math.random()*20+"px",t.style.animationDuration=3+Math.random()*2+"s",document.body.appendChild(t),setTimeout(()=>t.remove(),5e3)},t*100)}function s(e){const n=document.querySelector(".easter-egg-toast");n&&n.remove();const t=document.createElement("div");t.className="easter-egg-toast",t.textContent=e,document.body.appendChild(t),requestAnimationFrame(()=>t.classList.add("show")),setTimeout(()=>{t.classList.remove("show"),setTimeout(()=>t.remove(),300)},2500)}const o=["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"];let e=0;document.addEventListener("keydown",function(t){t.code===o[e]?(e++,e===o.length&&(e=0,a(),s("🎉 You found the secret!"))):e=0});let t=0,i=null;const n=document.querySelector(".logo a");n&&n.addEventListener("click",function(e){e.preventDefault(),t++,clearTimeout(i),t>=3?(t=0,r(),s("🚀 Let's go!")):i=setTimeout(()=>{t=0,window.location.href=n.href},500)})})()</script><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),document.documentElement.setAttribute("data-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),document.documentElement.setAttribute("data-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></div></body></html>